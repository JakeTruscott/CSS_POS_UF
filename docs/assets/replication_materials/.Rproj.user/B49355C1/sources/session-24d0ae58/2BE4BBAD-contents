---
title: "Number Generation and Loops"
subtitle: "POS6933: Computational Social Science"
author: "Truscott (Spring 2026)"
output:
  html_document:
    self_contained: false
    layout: null
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)

library(dplyr); library(ggplot2); library(ggtext); library(cowplot)

```


---

## Number Generation

<code>R</code> provides remarkable flexibility for randomly generating integers across a variety of distributions. Assuming I want to generate 1000 values at random, I can use many of <code>R's</code> built-in functionality to do so: 



```{r distributions}

set.seed(1234) # Random Seed 

uniform <- runif(1000, min = 0, max = 10) # Uniform Distribution

normal <- rnorm(1000, mean = 0, sd = 1) # Standard Normal (Mean = 0, SD = 1)

exponential <- rexp(1000, rate = 1) # Exponential Distribution (Rate = 1)

poisson <- rpois(1000, lambda = 3) # Poisson Distribution (Count)

binomial <- rbinom(1000, size = 10, prob = 0.5) # Bernoulli Distribution

geometric <- rgeom(1000, prob = 0.3) # Geometric Distribution

negative_binomial <- rnbinom(1000, size = 5, prob = 0.4) # Negative Binomial

chi_sq <- rchisq(1000, df = 4) # Chi-Square Distribution (4 Degrees of Freedom)

students_t <- rt(1000, df = 5) # Students T (5 DF)

```

```{r distribution_plots, echo=FALSE}

plot_continuous <- function(data, dist_fun, dist_args, title, bins = 30, from = min(data), to = max(data)) {
  ggplot(data.frame(x = data), aes(x)) +
    geom_histogram(aes(y = after_stat(density)), bins = bins,
                   fill = "skyblue4", color = "black", alpha = 0.4) +
    stat_function(fun = dist_fun, args = dist_args, color = "red", size = 1.2) +
    labs(title = title, x = '\n', y = 'Density\n') +
    theme_minimal() + 
    theme(panel.border = element_rect(linewidth = 1 , colour = 'black', fill = NA), 
          axis.title = element_text(size = 10, colour = 'black'), 
          axis.text = element_text(size = 8, colour = 'black'), 
          plot.title = element_text(size = 12, colour = 'black', vjust = 0.5, hjust = 0.5))
}

plot_discrete <- function(data, dist_fun, dist_args, title) {
  df <- data.frame(x = data)
  probs <- tibble::tibble(x = min(df$x):max(df$x),
                          p = dist_fun(min(df$x):max(df$x), !!!dist_args))
  ggplot(df, aes(x)) +
    geom_bar(aes(y = after_stat(prop)), fill = "skyblue4", color = "black", alpha = 0.6) +
    geom_point(data = probs, aes(x, p), color = "red", size = 1) +
    geom_line(data = probs, aes(x, p), color = "red", size = 1) +
    labs(title = title, x = '\n', y = "Probability\n", ) +
    theme_minimal() + 
     theme(panel.border = element_rect(linewidth =1 , colour = 'black', fill = NA), 
          axis.title = element_text(size = 10, colour = 'black'), 
          axis.text = element_text(size = 8, colour = 'black'), 
          plot.title = element_text(size = 12, colour = 'black', vjust = 0.5, hjust = 0.5))
}

p1 <- plot_continuous(uniform, dunif, list(min = 0, max = 10), "Uniform(0,10)")
p2 <- plot_continuous(normal, dnorm, list(mean = 0, sd = 1), "Normal(0,1)")
p3 <- plot_continuous(exponential, dexp, list(rate = 1), "Exponential(1)")
p4 <- plot_discrete(poisson, dpois, list(lambda = 3), "Poisson(3)")
p5 <- plot_discrete(binomial, dbinom, list(size = 10, prob = 0.5), "Binomial(10,0.5)")
p6 <- plot_discrete(geometric, dgeom, list(prob = 0.3), "Geometric(0.3)")
p7 <- plot_discrete(negative_binomial, dnbinom, list(size = 5, prob = 0.4), "Neg. Binomial(5,0.4)")
p8 <- plot_continuous(chi_sq, dchisq, list(df = 4), "Chi-Sq(4)")
p9 <- plot_continuous(students_t, dt, list(df = 5), "Student-t(5)")

final_plot <- plot_grid(p1, p2, p3,
                        p4, p5, p6,
                        p7, p8, p9,
                        ncol = 3, align = "v")


print(final_plot)


```
<br>
<b> Note:</b> Red lines illustrate theoretical distribution given parameters. 
<br>

<b>Additional Note Re: <i>Random</i> Number Generation</b>

In <code>R</code>, random number generation isn't truly random. Rather, they’re pseudo-random, meaning they use a deterministic algorithm to produce a sequence of numbers that appear random. A <code>seed</code> is the starting point for that algorithm. When you call <code>set.seed(1234)</code>, you are initializing the random number generator with a specific value. This ensures that every time you use the same seed, the sequence of "random" numbers <code>R</code> produces will be exactly the same -- perfect for reproducibility! 

---

## Loops


In R, a <code>for</code> loop is a control structure used to repeat a block of code a fixed number of times, iterating over a sequence of values. The basic syntax is:

```{r for_loop_syntax, eval=FALSE, include=TRUE}

for (variable in sequence){
  repeating code routine
}

```

where <code>variable</code> takes on each value in sequence one at a time, and the code inside the curly braces executes for each iteration. 

<code>for</code> loops are useful when you need to perform repetitive tasks, such as computing multiple summaries, filling a vector, or generating plots for several datasets. For example, imagine I wanted to print the squared integer of every value between 1 and 5. Rather than individually entering <code>{value}^5</code> to the console, I could simply iterate for each value:  

```{r for_loops}

for (i in 1:5){
  print(i^2) 
}

```
The syntax of these loops are fairly straightforward.Here, <code>i</code> takes on the value associated with each iteration. During the first pass, it will assume the value of 1. On the second pass, it will assume the value 2 -- so on and so forth until it reaches the terminal value of 5. 

<code>R</code> is also able to assume various syntax for assuming ranges of alphanumeric values. Here's just a few examples: 

```{R range_syntax}

values <- seq(10, 100, by = 10) # Values 10 to 100 by 10
print(values)

values <- c(10:20) # Values 10 to 20 (Inclusive)
print(values)

values <- seq(1, 100, by = 1) # All Values 1 to 100 (Inclusive)

for (i in values){
  if (i %% 10 == 0){
    print(i)
  }
} # For Each Value in `values', if i is neatly divisible by 10, print i

values <- c('a', 'b', 'c', 'd', 'f') 

for (i in 1:length(values)){
  print(values[i])
} # For Each Value in Values, Print the Value Indexed values[i]

```


<br> 

### Simulating Normal Distribution

I could even bake the syntax of <code>for</code> loops into random number generation to significantly increase my efficiency in modeling distributions. Let's imagine I want to visualize the capacity for repeated sampling to best mimic a standard normal distribution where $\mu$ = 50 and $\sigma$ = 5. Using a <code>for</code> loop, I can cycle different sampling rates to answer this question: 

```{r for_loops_sampling}

results <- data.frame() # Empty Dataframe to Store Output
samples <- c(10, 100, 1000, 10000) # Vector of Integers

for (i in 1:length(samples)){
  
  temp_sample_size <- samples[i] # Recovers the i-th value of the samples vector
  temp_run <- rnorm(temp_sample_size, mean = 50, sd = 5) # Run 
  temp_run <- data.frame(sample_size = temp_sample_size, 
                         value = temp_run) # Create Temporary dataframe indicating size of samples and values from rbinom()
  results <- bind_rows(results, temp_run) # Export to 'results' data.frame
  
}

summary(results) # Print Summary


results %>%
  mutate(sample_size = factor(sample_size)) %>%
  ggplot(aes(x = value)) + 
  geom_density(aes(fill = sample_size), alpha = 1/3) + 
  stat_function(fun = dnorm, args = list(mean = 50, sd = 5), 
                color = "red", linewidth = 1.2) + 
  labs(x = '\nValue',
       y = 'Density\n', 
       fill = 'Sample Size', 
       caption = 'Note: Red Line Indicates Normal Distribution (μ = 50, σ = 5)') + 
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 50, linetype = 2) + 
  facet_wrap(~paste0(sample_size, ' Samples')) + 
  scale_x_continuous(breaks = seq(35, 65, 5)) + 
  theme_minimal() + 
  theme(panel.border = element_rect(linewidth = 1, colour = 'black', fill = NA), 
        axis.text = element_text(size = 12, colour = 'black'), 
        axis.title = element_text(size = 14, colour = 'black'), 
        strip.background = element_rect(linewidth = 1, colour = 'black', fill = 'grey75'),
        strip.text = element_text(size = 12, colour = 'black'), 
        legend.position = 'none', 
        plot.caption = element_text(hjust = 0.5)) 

```

<br> 

### Games of Chance Example (Roulette)


I could even use <code>for</code> loops to simulate games of chance. For example, a standard American roulette wheel has 38 slots: 
<ul>
  <li style="color: red;"><b>18 Red</b></li>
  <li style="color: black;"><b>18 Black</b></li>
  <li style="color: green;"><b>2 Green</b></li>
</ul>

<br>

<img src="/assets/images/roulette_wheel.jpg" alt="Standard American Roulette Wheel" width="600">

<br>

However, to only play the colors at a 1-1 payout (i.e., receiving a payout equal to your initial bet) means I can only select <b>Black</b> or <span style="color:red;">Red</span>, each of which have a 0.47\% (<sup>18</sup>&frasl;<sub>38</sub>) probability of being selected for any independent spin. Let's say I played 50 times, each time selecting from among <b>Black</b> or <span style="color:red;">Red</span>. I only have one rule: <b> If I win, I place the same bet as before. If I lose, I play the other color</b>. If I begin with \$500 and bet the table minimum (\$10), what might I be expected to finish with if I visit 100 times and play 100 spins each time? 

```{r roulette}

set.seed(1234) # Set Initial Seed
seeds <-  sample(1:1000, size = 100, replace = FALSE) # Random Seeds
roulette_values <- c(rep("red", 18), rep("black", 18), rep("green", 2)) # Roulette Wheel
games <- c() # Empty Vector to Store Winnings (Losses...)

for (i in 1:length(seeds)){
  
  temp_seed <- seeds[i] # Recover Temporary Seed
  set.seed(temp_seed) # Set Temporary Seed
  
  available_colors <- c('red', 'black') # Available Roulette Colors
  remaining_funds <- 500 # Starting Money
  current_color <- 'red' # Starting with Red
  
  for (spin in 1:100){
    
    temp_spin <- sample(roulette_values, size = 1, replace = T) # Spin!
    
    if (temp_spin == current_color){
      remaining_funds <- remaining_funds + 10 # Win :D 
      current_color = current_color # Keep Color
    } else {
      remaining_funds <- remaining_funds - 10 # Loss :(
      current_color = sample(available_colors[which(!available_colors == current_color)], size = 1, replace = T)
      # If Loss -- Remove $10 and Change Color to Other from Remaining Options
    }
  }
  games <- c(games, remaining_funds) # Export Remaining Funds
}


data.frame(remaining_funds = games) %>%
  ggplot(aes(x = remaining_funds)) + 
    geom_histogram(aes(y = after_stat(density)),  
                 fill = 'skyblue4', colour = 'black', alpha = 1/3, bins = 20) + 
  geom_density(colour = 'red', linetype = 2, linewidth = 1) + 
  labs(x = '\nRemaining Funds\n',
       y = 'Density\n', 
       fill = 'Sample Size', 
       caption = paste0( "Dashed Black Line = Average Remaining Funds Each Day ($", round(mean(games), 0), ")\n",
                         "Dashed Red Line = Starting Funds ($500)" )) + 
  geom_vline(xintercept = 500, linetype = 2, colour = 'red') + 
  geom_vline(xintercept = mean(games), linetype = 2, colour = 'black') + 
  geom_hline(yintercept = 0) +
  theme_minimal() + 
  theme(panel.border = element_rect(linewidth = 1, colour = 'black', fill = NA), 
        axis.text = element_text(size = 12, colour = 'black'), 
        axis.title = element_text(size = 14, colour = 'black'), 
        strip.background = element_rect(linewidth = 1, colour = 'black', fill = 'grey75'),
        strip.text = element_text(size = 12, colour = 'black'), 
        legend.position = 'none', 
        plot.caption = element_text(hjust = 0, size = 10)) 

```

Now what if I changed the rules such that instead of restarting with \$500 each day, I assume the value of the day before? 

```{r roulette_inherit_money, echo=FALSE}

set.seed(1234) # Set Initial Seed
seeds <-  sample(1:1000, size = 100, replace = FALSE) # Random Seeds
roulette_values <- c(rep("red", 18), rep("black", 18), rep("green", 2)) # Roulette Wheel
games <- c() # Empty Vector to Store Winnings (Losses...)

for (i in 1:length(seeds)){
  
  temp_seed <- seeds[i] # Recover Temporary Seed
  set.seed(temp_seed) # Set Temporary Seed
  
  available_colors <- c('red', 'black') # Roulette Colors
  remaining_funds <- ifelse(i == 1, 500, games[i-1])  # Starting Money (500 or Previous Start if i > 1)
  current_color <- 'red' # Starting with Red
  
  for (spin in 1:100){
    
    temp_spin <- sample(roulette_values, size = 1, replace = T) # Spin!
    
    if (temp_spin == current_color){
      remaining_funds <- remaining_funds + 10 # Win :D 
      current_color = current_color # Keep Color
    } else {
      remaining_funds <- remaining_funds - 10 # Loss :(
      current_color = sample(available_colors[which(!available_colors == current_color)], size = 1, replace = T)
      # If Loss -- Remove $10 and Change Color to Other from Remaining Options
    }
  }
  games <- c(games, remaining_funds) # Export Remaining Funds
}


data.frame(remaining_funds = games) %>%
  ggplot(aes(x = remaining_funds)) + 
    geom_histogram(aes(y = after_stat(density)),  
                 fill = 'skyblue4', colour = 'black', alpha = 1/3, bins = 15) + 
  geom_density(colour = 'red', linetype = 2, size = 1) + 
  labs(x = '\nRemaining Funds\n',
       y = 'Density\n', 
       fill = 'Sample Size', 
       caption = paste0(
      "Dashed Black Line = Average Remaining Funds After 100 Days $(", round(mean(games), 0), ")"
    )) + 
  geom_vline(xintercept = 500, linetype = 2, colour = 'red') + 
  geom_vline(xintercept = mean(games), linetype = 2, colour = 'black') + 
  geom_hline(yintercept = 0) +
  theme_minimal() + 
  theme(panel.border = element_rect(linewidth = 1, colour = 'black', fill = NA), 
        axis.text = element_text(size = 12, colour = 'black'), 
        axis.title = element_text(size = 14, colour = 'black'), 
        strip.background = element_rect(linewidth = 1, colour = 'black', fill = 'grey75'),
        strip.text = element_text(size = 12, colour = 'black'), 
        legend.position = 'none', 
        plot.caption = element_text(hjust = 0, size = 10)) 

```
