---
title: "Number Generation and Loops"
subtitle: "POS6933: Computational Social Science"
author: "Truscott (Spring 2026)"
output:
  html_document:
    self_contained: false
    layout: null
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr); library(ggplot2)

```

---

## Number Generation

<code>R</code> provides remarkable flexibility for randomly generating integers across a variety of distributions. Assuming I want to generate 1000 values at random, I can use many of <code>R's</code> built-in functionality to do so: 



```{r distributions}

set.seed(1234) # Random Seed 

uniform <- runif(1000, min = 0, max = 10) # Uniform Distribution
summary(uniform)

normal <- rnorm(1000, mean = 0, sd = 1) # Standard Normal (Mean = 0, SD = 1)
summary(normal)

exponential <- rexp(1000, rate = 1) # Exponential Distribution (Rate = 1)
summary(exponential)

poisson <- rpois(1000, lambda = 3) # Poisson Distribution (Count)
summary(poisson)

binomial <- rbinom(1000, size = 10, prob = 0.5) # Bernoulli Distribution
summary(binomial)

geometric <- rgeom(1000, prob = 0.3) # Geometric Distribution
summary(geometric)

negative_binomial <- rnbinom(1000, size = 5, prob = 0.4) # Negative Binomial
summary(negative_binomial)

chi_sq <- rchisq(1000, df = 4) # Chi-Square Distribution (4 Degrees of Freedom)
summary(chi_sq)

students_t <- rt(1000, df = 5) # Students T (5 DF)
summary(students_t)

```


<b> Note:</b> In <code>R</code>, random number generation isn't truly random. Rather, they’re pseudo-random, meaning they use a deterministic algorithm to produce a sequence of numbers that appear random. A <code>seed</code> is the starting point for that algorithm. When you call <code>set.seed(1234)</code>, you are initializing the random number generator with a specific value. This ensures that every time you use the same seed, the sequence of "random" numbers <code>R</code> produces will be exactly the same -- perfect for reproducibility! 

---

## Loops


In R, a for loop is a control structure used to repeat a block of code a fixed number of times, iterating over a sequence of values. The basic syntax is <code>for(variable in sequence) { code }</code>, where <code>variable</code> takes on each value in sequence one at a time, and the code inside the curly braces executes for each iteration. 

<code>for</code> loops are useful when you need to perform repetitive tasks, such as computing multiple summaries, filling a vector, or generating plots for several datasets. For example, imagine I wanted to print the squared integer of every value between 1 and 5. Rather than individually entering <code>{value}^5</code> to the console, I could simply iterate for each value:  

```{r for_loops}

for (i in 1:5){
  print(i^2) 
}

```
The syntax of these loops are fairly straightforward.Here, <code>i</code> takes on the value associated with each iteration. During the first pass, it will assume the value of 1. On the second pass, it will assume the value 2 -- so on and so forth until it reaches the terminal value of 5. 

<code>R</code> is able to assume various syntax for assuming ranges of alphanumeric values. Here's just a few examples: 

```{R range_syntax}

values <- seq(10, 100, by = 10) # Values 10 to 100 by 10
print(values)

values <- c(10:20) # Values 10 to 20 (Inclusive)
print(values)

values <- seq(1, 100, by = 1) # All Values 1 to 100 (Inclusive)

for (i in values){
  if (i %% 10 == 0){
    print(i)
  }
} # For Each Value in `values', if i is neatly divisible by 10, print i

values <- c('a', 'b', 'c', 'd', 'f') 

for (i in 1:length(values)){
  print(values[i])
} # For Each Value in Values, Print the Value Indexed values[i]

```


<br> 

### Simulating Normal Distribution

I could even bake the syntax of <code>for</code> loops into random number generation to significantly increase my efficiency in modeling distributions. Let's imagine I want to visualize the capacity for repeated sampling to best mimic a standard normal distribution where $\mu$ = 50 and $\sigma$ = 5. Using a <code>for</code> loop, I can cycle different sampling rates to answer this question: 

```{r for_loops_sampling}

results <- data.frame() # Empty Dataframe to Store Output
samples <- c(10, 100, 1000, 10000) # Vector of Integers

for (i in 1:length(samples)){
  
  temp_sample_size <- samples[i] # Recovers the i-th value of the samples vector
  temp_run <- rnorm(temp_sample_size, mean = 50, sd = 5) # Run 
  temp_run <- data.frame(sample_size = temp_sample_size, 
                         value = temp_run) # Create Temporary dataframe indicating size of samples and values from rbinom()
  results <- bind_rows(results, temp_run) # Export to 'results' data.frame
  
}

summary(results) # Print Summary


results %>%
  mutate(sample_size = factor(sample_size)) %>%
  ggplot(aes(x = value)) + 
  geom_density(aes(fill = sample_size), alpha = 1/3) + 
  stat_function(fun = dnorm, args = list(mean = 50, sd = 5), 
                color = "red", linewidth = 1.2) + 
  labs(x = '\nValue',
       y = 'Density\n', 
       fill = 'Sample Size', 
       caption = 'Note: Red Line Indicates Normal Distribution (μ = 50, σ = 5)') + 
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 50, linetype = 2) + 
  facet_wrap(~paste0(sample_size, ' Samples')) + 
  scale_x_continuous(breaks = seq(35, 65, 5)) + 
  theme_minimal() + 
  theme(panel.border = element_rect(linewidth = 1, colour = 'black', fill = NA), 
        axis.text = element_text(size = 12, colour = 'black'), 
        axis.title = element_text(size = 14, colour = 'black'), 
        strip.background = element_rect(linewidth = 1, colour = 'black', fill = 'grey75'),
        strip.text = element_text(size = 12, colour = 'black'), 
        legend.position = 'none', 
        plot.caption = element_text(hjust = 0.5)) 

```

<br> 

### Games of Chance Example


I could even use <code>for</code> loops to simulate games of chance. For example, a standard American roulette wheel has 38 slots: 
<ul>
  <li style="color: red;">18 Red</li>
  <li style="color: black;">18 Black</li>
  <li style="color: green;">2 Green</li>
</ul>

Let's say I played 50 times, each time selecting from among the three color options. I only have one rule: <b> If I win, I place the same bet as before. If I lose, I play a different color</b>. 

If I begin with \$500 and bet the table minimum (\$10), what might I be expected to finish with if I visit 100 times and play 50 spins each time?


```{r roulette}

set.seed(1234) # Set Initial Seed
seeds <-  sample(1:1000, size = 100, replace = FALSE) # Random Seeds
roulette_values <- c(rep("red", 18), rep("black", 18), rep("green", 2)) # Roulette Wheel
games <- c() # Empty Vector to Store Winnings (Losses...)

for (i in 1:length(seeds)){
  
  temp_seed <- seeds[i] # Recover Temporary Seed
  set.seed(temp_seed) # Set Temporary Seed
  
  available_colors <- c('red', 'black', 'green') # Roulette Colors
  remaining_funds <- 500 # Starting Money
  current_color <- 'red' # Starting with Red
  
  for (spin in 1:100){
    
    temp_spin <- sample(roulette_values, size = 1, replace = T) # Spin!
    
    if (temp_spin == current_color){
      remaining_funds <- remaining_funds + 10 # Win :D 
      current_color = current_color # Keep Color

    } else {
      remaining_funds <- remaining_funds - 10 # Loss :(
      current_color = sample(available_colors[which(!available_colors == current_color)], size = 1, replace = T)

      # If Loss -- Remove $10 and Change Color to Other from Remaining Options
      
    }
    
    
  }
  
  games <- c(games, remaining_funds) # Export Remaining Funds
  
}


data.frame(remaining_funds = games) %>%
  ggplot(aes(x = remaining_funds)) + 
  geom_histogram(fill = 'skyblue4', colour = 'black', alpha = 1/3, bins = 20) + 
  labs(x = '\nRemaining Funds\n',
       y = 'Count\n', 
       fill = 'Sample Size', 
       caption = paste0(
      "Dashed Black Line = Average Remaining Funds Each Day ($", round(mean(games), 0), ")\n",
      "Dashed Red Line = Starting Funds ($500)"
    )) + 
  geom_vline(xintercept = 500, linetype = 2, colour = 'red') + 
  geom_vline(xintercept = mean(games), linetype = 2, colour = 'black') + 
  geom_hline(yintercept = 0) +
  theme_minimal() + 
  theme(panel.border = element_rect(linewidth = 1, colour = 'black', fill = NA), 
        axis.text = element_text(size = 12, colour = 'black'), 
        axis.title = element_text(size = 14, colour = 'black'), 
        strip.background = element_rect(linewidth = 1, colour = 'black', fill = 'grey75'),
        strip.text = element_text(size = 12, colour = 'black'), 
        legend.position = 'none', 
        plot.caption = element_text(hjust = 0, size = 10)) 

```

Now what if I changed the rules such that instead of restarting with \$500 each day, I assume the value of the day before? 

```{r roulette_inherit_money}

set.seed(1234) # Set Initial Seed
seeds <-  sample(1:1000, size = 100, replace = FALSE) # Random Seeds
roulette_values <- c(rep("red", 18), rep("black", 18), rep("green", 2)) # Roulette Wheel
games <- c() # Empty Vector to Store Winnings (Losses...)

for (i in 1:length(seeds)){
  
  temp_seed <- seeds[i] # Recover Temporary Seed
  set.seed(temp_seed) # Set Temporary Seed
  
  available_colors <- c('red', 'black', 'green') # Roulette Colors
  remaining_funds <- ifelse(i == 1, 500, games[i-1])  # Starting Money (500 or Previous Start if i > 1)
  current_color <- 'red' # Starting with Red
  
  for (spin in 1:100){
    
    temp_spin <- sample(roulette_values, size = 1, replace = T) # Spin!
    
    if (temp_spin == current_color){
      remaining_funds <- remaining_funds + 10 # Win :D 
      current_color = current_color # Keep Color
    } else {
      remaining_funds <- remaining_funds - 10 # Loss :(
      current_color = sample(available_colors[which(!available_colors == current_color)], size = 1, replace = T)

      # If Loss -- Remove $10 and Change Color to Other from Remaining Options
      
    }
    
    
  }
  
  games <- c(games, remaining_funds) # Export Remaining Funds
  
}


data.frame(remaining_funds = games) %>%
  ggplot(aes(x = remaining_funds)) + 
  geom_histogram(fill = 'skyblue4', colour = 'black', alpha = 1/3, bins = 50) + 
  labs(x = '\nRemaining Funds\n',
       y = 'Count\n', 
       fill = 'Sample Size', 
       caption = paste0(
      "Dashed Black Line = Average Remaining Funds Each Day ($", round(mean(games), 0), ')'
    )) + 
  geom_vline(xintercept = mean(games), linetype = 2, colour = 'black') + 
  geom_hline(yintercept = 0) +
  theme_minimal() + 
  theme(panel.border = element_rect(linewidth = 1, colour = 'black', fill = NA), 
        axis.text = element_text(size = 12, colour = 'black'), 
        axis.title = element_text(size = 14, colour = 'black'), 
        strip.background = element_rect(linewidth = 1, colour = 'black', fill = 'grey75'),
        strip.text = element_text(size = 12, colour = 'black'), 
        legend.position = 'none', 
        plot.caption = element_text(hjust = 0, size = 10)) 

```

<simulate the numbers>
